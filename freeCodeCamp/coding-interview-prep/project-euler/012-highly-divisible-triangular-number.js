// https://www.freecodecamp.org/learn/coding-interview-prep/project-euler/problem-12-highly-divisible-triangular-number
// The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
// Let us list the factors of the first seven triangle numbers:
// 1: 1
// 3: 1, 3
// 6: 1, 2, 3, 6
// 10: 1, 2, 5, 10
// 15: 1, 3, 5, 15
// 21: 1, 3, 7, 21
// 28: 1, 2, 4, 7, 14, 28
// We can see that 28 is the first triangle number to have over five divisors.
// What is the value of the first triangle number to have over n divisors?

// slow factorial: TIMED OUT for large numbers
function divisibleTriangleNumber2(n) {

    // let counter = 0;

    if (n < 2) return 1;

    let number = 1;
    let sum;
    let factors = {};

    do {
        // get a new number
        number++;

        // generate the sum of the number
        sum = number * (number + 1) / 2;

        // empty the factors object
        factors = {};

        // add obvious factors
        factors[1] = 1;
        factors[sum] = 1;

        for (let i = 2; i <= sum / 2; i++) {
            if (sum % i === 0) {
                factors[i] = (factors[i] || 0) + 1;
            }
            // counter++;
        }

    } while (Object.keys(factors).length < n)

    // console.log(`Iterartions: ${counter}`);
    return sum;
}

// better factorial search
function divisibleTriangleNumber(n) {

    // let counter = 0;

    if (n < 2) return 1;

    let number = 1;
    let sum;
    let factors = {};

    do {
        // get a new number
        number++;

        // generate the sum of the number
        sum = number * (number + 1) / 2;

        // empty the factors object
        factors = {};

        // add factors
        // https://www.mathsisfun.com/numbers/factors-all-tool.html
        let div_lower = 1;
        let div_upper = sum;

        while (div_lower < div_upper) {
            if (sum % div_lower === 0) {
                factors[div_lower] = (factors[div_lower] || 0) + 1;
            }

            if (sum % div_upper === 0) {
                factors[div_upper] = (factors[div_upper] || 0) + 1;
            }
            div_lower += 1;
            div_upper = Math.floor(sum / div_lower);
            // counter++;
        }

    } while (Object.keys(factors).length < n)

    // console.log(`Iterations: ${counter}`);
    return sum;
}


console.log(divisibleTriangleNumber(5), 28);
console.log(divisibleTriangleNumber(23), 630);
console.log(divisibleTriangleNumber(167), 1385280);
console.log(divisibleTriangleNumber(374), 17907120);
console.log(divisibleTriangleNumber(500), 76576500);

//                       Slow factorial         Better factorial
// Iterations / runtime: 34 (8 ms)              16 (8 ms)
//                       3842 (10 ms)           424 (8 ms)
//                       384,644,001 (14 s)     978,468 (42 ms)
//                       17,865,329,241 (71 s)  12,658,381 (200 ms)
//                                              54,139,766 (654 ms)
